<?xml version="1.0" encoding="UTF-8"?>
<!--
  ! CCPL HEADER START
  !
  ! This work is licensed under the Creative Commons
  ! Attribution-NonCommercial-NoDerivs 3.0 Unported License.
  ! To view a copy of this license, visit
  ! http://creativecommons.org/licenses/by-nc-nd/3.0/
  ! or send a letter to Creative Commons, 444 Castro Street,
  ! Suite 900, Mountain View, California, 94041, USA.
  !
  ! You can also obtain a copy of the license at legal-notices/CC-BY-NC-ND.txt.
  ! See the License for the specific language governing permissions
  ! and limitations under the License.
  !
  ! If applicable, add the following below this CCPL HEADER, with the fields
  ! enclosed by brackets "[]" replaced with your own identifying information:
  !      Portions Copyright [yyyy] [name of copyright owner]
  !
  ! CCPL HEADER END
  !
  !      Copyright 2011-2015 ForgeRock AS.
  !    
-->
<chapter xml:id='chap-using-the-sdk'
         xmlns='http://docbook.org/ns/docbook' version='5.0' xml:lang='en'
         xmlns:xsi='http://www.w3.org/2001/XMLSchema-instance'
         xsi:schemaLocation='http://docbook.org/ns/docbook
                             http://docbook.org/xml/5.0/xsd/docbook.xsd'
         xmlns:xlink='http://www.w3.org/1999/xlink'>
 <title>Using the LDAP SDK</title>

 <para>
  As LDAP relies on a connection
  from the client application to the directory server,
  the starting point for working with the LDAP SDK is
  a new <literal>LDAPConnectionFactory</literal>.
  The connection factory allows an application to get a connection
  either synchronously or asynchronously.
  The application then uses the connection
  to make requests and to get responses from the directory server.
 </para>

 <section xml:id="sync-vs-async">
  <title>Synchronous vs. Asynchronous APIs</title>

  <para>
   The LDAP SDK offers synchronous and asynchronous APIs.
   The difference is that synchronous APIs
   wait for each task to complete before starting the next task,
   whereas asynchronous APIs
   allow another task to start before the current one finishes.
  </para>

  <section xml:id="sync-apis">
   <title>Synchronous APIs</title>

   <indexterm>
    <primary>Connections</primary>
    <secondary>Synchronous</secondary>
   </indexterm>

   <para>
    For synchronous operations the application gets a connection
    from a connection factory,
    and then requests operations on the connection in sequence.
    When finished, the application closes the connection
    as shown in the following example:
   </para>

   <programlisting language="java">
[jcp:org.forgerock.opendj.examples.Search:--- JCite ---]
   </programlisting>

   <para>
    For the complete example in context, see
    <link
     xlink:href="../resources/org/forgerock/opendj/examples/Search.java"
     xlink:show="new"
    >Search.java</link>.
   </para>
  </section>

  <section xml:id="async-apis">
   <title>Asynchronous APIs</title>

   <indexterm>
    <primary>Connections</primary>
    <secondary>Asynchronous</secondary>
   </indexterm>

   <para>
    Asynchronous code can be tricky to read and to write.
    To make coding easier,
    the asynchronous APIs use <firstterm>promises</firstterm>.
    Promises might be familiar to JavaScript developers.
    A promise is the result of a task that might or might not be complete.
    Fluent code style, which strings together chains of methods,
    works well with promises.
   </para>

   <para>
    The following code outline chains asynchronous calls together:
   </para>

   <programlisting language="java"><![CDATA[
class AsyncApp {
    private Connection connection;

    public void myMethod(String host, int port) {
        // Get a connection to the directory asynchronously,
        // returning a promise (with the connection if all goes well).
        new LDAPConnectionFactory(host, port)
            .getConnectionAsync()

            // Bind asynchronously, returning a promise with the bind result.
            // Notice the connection is consumed, the bind result produced.
            .thenAsync(new AsyncFunction<Connection, BindResult, LdapException>() {
                @Override
                public Promise<BindResult, LdapException> apply(Connection connection)
                        throws LdapException {
                    SearchAsync.connection = connection;
                    return AsyncApp.bindAsync(
                        Requests.newSimpleBindRequest(bindDn, password));
                }
            })

            // When the bind completes, perform an LDAP operation,
            // returning a promise with the result of the operation.
            // Here the bind result is consumed, and the next result produced.
            .thenAsync(new AsyncFunction<BindResult, Result, LdapException>() {
                @Override
                public Promise<Result, LdapException> apply(BindResult bindResult)
                        throws LdapException {
                    // Return a promise from an asynchronous method.
                    // return connection.***Async(...);
                }
            })
            // An application might chain several more calls together.
            // .thenAsync(new AsyncFunction<Result, Result, LdapException>() {...
            // .thenAsync(new AsyncFunction<Result, Result, LdapException>() {...
            // ...

            // Handle the result, if any.
            .thenOnResult(new ResultHandler<Result>() {
                @Override
                public void handleResult(Result result) {
                    // Handle the result.
                }
            })

            // Handle any exceptions that arise.
            .thenOnException(new ExceptionHandler<LdapException>() {
                @Override
                public void handleException(LdapException e) {
                    // Handle exceptions.
                }
            });

        closeSilently(connection);
        return;
    }
}
   ]]></programlisting>

   <para>
    The following example demonstrates a search using the asynchronous APIs:
   </para>

   <programlisting language="java">
[jcp:org.forgerock.opendj.examples.SearchAsync:--- Using Promises ---]
   </programlisting>

   <para>
    When the factory gets a connection,
    the application passes an <literal>AsyncFunction</literal>
    to apply to the connection to handle the bind
    by using the <literal>thenAsync()</literal> method in the fluent style.
    The application uses <literal>thenAsync()</literal> again
    to pass another <literal>AsyncFunction</literal> to perform the operation.
    In the sample shown here, the second call to <literal>thenAsync()</literal>
    passes a function that performs a search,
    using a handler to deal with the search results returned by the server.
    The call to <literal>thenOnResult()</literal> handles the final result,
    with the call to <literal>thenOnException()</literal> dealing with exceptions.
   </para>

   <para>
    The application must coordinate concurrency when using asynchronous APIs.
   </para>

   <para>
    For the complete example in context, see
    <link
     xlink:href="../resources/org/forgerock/opendj/examples/SearchAsync.java"
     xlink:show="new"
    >SearchAsync.java</link>.
   </para>
  </section>
 </section>

 <section xml:id="error-handling">
  <title>Managing Errors</title>
  <indexterm>
   <primary>Errors</primary>
  </indexterm>

  <para>LDAP <link xlink:href="http://tools.ietf.org/html/rfc4511#appendix-A"
  xlink:show="new">defines many result codes</link> to deal with conditions
  other than success. The <literal>ResultCode</literal> class encapsulates the
  LDAP codes and additional client-side codes specific to the SDK.</para>

  <para>
   Your application deals with most non-success result codes
   by catching <literal>LdapException</literal> objects
   or handling them when supplied to <literal>FailureHandler</literal> objects
   passed to <literal>onFailure()</literal> methods.
   Your application can then take remedial action based on the result code,
   as in the following synchronous example.
  </para>

  <programlisting language="java">
final LDAPConnectionFactory factory = new LDAPConnectionFactory(host, port);
Connection connection = null;

try {
    connection = factory.getConnection();
    connection.bind(name, password);

    // Perform operations on the connection...

} catch (final LdapException e) {

    // Take remedial action based on the result code...
    // e.getResult().getResultCode() returns the code for you to interpret.

} finally {
    if (connection != null) {
        connection.close();
    }
}
  </programlisting>

  <para>
   Also notice the methods <literal>ResultCode.getName()</literal>
   that provides a short, human-readable version of the result code,
   and <literal>Result.getDiagnosticMessage()</literal>
   that can help to debug problems after the fact.
  </para>

  <para>
   When you have completely finished with a connection,
   then use the <literal>close()</literal> method on it.
  </para>
 </section>

 <!-- Pending https://bugster.forgerock.org/jira/browse/OPENDJ-178
 <section xml:id="referral-handling">
  <title>Managing Referrals</title>
  <indexterm>
   <primary>Searches</primary>
   <secondary>Handling results</secondary>
  </indexterm>
  <indexterm>
   <primary>Referrals</primary>
  </indexterm>

  <para></para>
 </section>
 -->
</chapter>